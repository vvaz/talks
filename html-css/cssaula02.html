<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>HTML - CSS // Flag</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="./css/tailwind.min.css">
  <link rel="stylesheet" href="../revealjs/dist/reveal.css">
  <link rel="stylesheet" href="../revealjs/dist/theme/black.css" id="theme">
  <link rel="stylesheet" href="../revealjs/plugin/highlight/monokai.css">
  <link rel="stylesheet" href="./css/custom.css">
</head>

<body>

		<div class="reveal">


			<div class="slides">


				<section class="text-left">
					<h2>IDs e !important</h2>

					<p>
						No contexto dos CSS, nunca deveriamos usar o selector das IDs nem o comando !important. São duas ferramentas muito destruidoras, mas temos de saber o que fazem, principalmente porque aparecem muitas vezes em tutoriais e soluções de código online. (No contexto de JavaScript, as IDs podem e devem ser usadas).
					</p>

				</section>

				<section class="text-left">
					<pre>
						<code class="hljs" data-trim contenteditable>
							&lt;style type="text/css"&gt;
								#site-brand {
									color: red;
								}

								h1.nav-head.nav-main.other-useful-class {
									color: green;
								}
							&lt;/style&gt;
							<h1 id="site-brand" class="nav-head nav-main other-useful-class">
								The Brand of my Website
							</h1>
					 </code>
				 </pre>
				</section>


				<section class="text-left">
					<small>
						<h2>Pseudoclasses</h2>
						<small>(lê-se sudoclasses)</small>

						<p>
							Às vezes, queremos mudar como os elementos aparecem baseado em certos eventos que acontecem no DOM. Uma dessas situações acontece quando queremos mudar a aparência de um elemento quando passamos com o rato por cima desse elemento.
						</p>
					</small>
					<pre>
						<code class="hljs" data-trim contenteditable>
							&lt;style&gt;
								.hover-example {
									width: 100px;
									height: 100px;
									background-color: limegreen;
									color: white;
								}
								.hover-example:hover {
									background-color: crimson;
									width: 150px;
									height: 150px;
								}
								&lt;/style&gt;
								&lt;div class="hover-example"&gt;Hover your mouse over me&lt;/div&gt;
					 </code>
				 </pre>

				</section>


				<section class="text-left">
					<p>A parte do :hover seleciona o elemento, quando a condição é verdadeira.</p>
					<p>É como um trigger para um evento. Conseguimos "captar" o momento que algo acontece e definimos algo para depois disso acontecer.</p>
					<p>Outros exemplos: :first-child :last-child :nth-child(n) :first-letter</p>
				</section>

				<section class="text-left">
					<p>Os elementos :hover são muito utilizados para links e navegações.</p>
					<p>Existem outros para as hyperligações como o :active e o :visited por exemplo</p>
				</section>

				<section class="text-left">
					<p>Podemos também usar os pseudoelementos ::before e o ::after para introduzir algo antes ou depois do elemento HTML</p>
					<p>Atenção aos 2 :: antes. É usado para distinguir pseudoclasses de pseudoelementos. IE8 não suporta. </p>
				</section>

				<section class="text-left">
					<pre>
						<code class="hljs" data-trim contenteditable>
							div::before {
								content: "conteúdo antes";
							}
							div::after {
								content: "conteúdo depois";
							}
					 </code>
				 </pre>

				 <pre>
					<code class="hljs" data-trim contenteditable>
						<div>
							conteúdo antes
							&lt;!-- o conteúdo vem aqui --&gt;
							conteúdo depois
						</div>
				 </code>
			 </pre>
				</section>

				<section class="text-left">
					<p>Há muitas outras pseudoclasses em CSS que podem ver <a href="https://css-tricks.com/pseudo-class-selectors/">neste artigo</a></p>
				</section>

				<section class="text-left">
					<h2>Box Model</h2>

					<p>é o conceito mais dificil de aprender, mas nós já temos usado todas as funcionalidades do box model até aqui</p>
				</section>

				<section class="text-left">
					<p>Consistem em display, width, height, border, margin e paddings (e o seu conteúdo).</p>
					<small>
						<p>Por defeito no CSS, existem vários elementos por default (ex: a cor do texto ser sempre preta), e o display assume vários defaults. Nas divs temos o display:block, na span temos o display:inline por exemplo (e faz sentido consoante o que os elementos têm de fazer por default).</p>
					</small>
				</section>

				<section class="text-left">
					<h2>Flex</h2>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.flex-container {
								display: flex;
							}
					 </code>
				 </pre>

				</section>

				<section class="text-left">
					<h2>Propriedades do pai Flex</h2>
				</section>

				<section class="text-left">
					<h2>Flex</h2>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.flex-container {
								display: flex;
							}
					 </code>
				 </pre>

				 <small>
					<p>Define um container para o flex. Habilita o display flex para os seus filhos diretos</p>
				 </small>
				</section>



				<section class="text-left">
					<p>flex-direction</p>
					<small>
						<p>
							Estabelece o eixo principal e a sua direção.
						</p>
						<img src="img/flex-direction.svg" alt="" style="width: 100%; height: auto;">
					</small>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.flex-container {
								flex-direction: row | row-reverse | column | column-reverse;
							}
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<p>flex-wrap</p>
					<small>
						<p>
							Por defeito, todos os flex items vão tentar ficar na mesma linha. Podemos mudar esse comportamento com o flex-wrap.
						</p>
						<img src="img/flex-wrap.svg" alt="">
					</small>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.flex-container {
								flex-wrap: nowrap | wrap | wrap-reverse;
							}
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<p>justify-content</p>
					<small>
						<p>
							Define o alinhamento sobre o eixo principal. Ajuda a distribuir espaço livre pelos elementos onde não é indicado uma dimensão.

						</p>
						<img src="img/justify-content.svg" alt="">
					</small>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.flex-container {
								justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe;
							}
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<p>align-items</p>
					<small>
						<p>
							Define o alinhamento sobre o eixo secundário. Podemos pensar nele como um justify-content mas para o outro eixo - perpendicular ao eixo principal.
						</p>
						<img src="img/align-items.svg" alt="" style="width: auto; height: 318px;">
					</small>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.flex-container {
								align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;
							}
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<p>align-content</p>
					<small>
						<p>
							Define o alinhamento sobre as linhas dependendo do espaço disponível no eixo secundário.

						</p>
						<img src="img/align-content.svg"  style="width: auto; height: 318px;">
					</small>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.flex-container {
								align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;
							}
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<p>gap, row-gap, column-gap</p>
					<small>
						<p>
							Controla o espaço entre items flex.

						</p>
						<img src="img/gap-1.svg"  style="width: auto; height: 318px;">
					</small>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.flex-container {
								display: flex;
								...
								gap: 10px;
								gap: 10px 20px; /* row-gap column gap */
								row-gap: 10px;
								column-gap: 20px;
							}
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<h2>Propriedades dos filhos Flex</h2>
				</section>

				<section class="text-left">
					<p>order</p>
					<small>
						<p>
							Define a ordem dos items.

						</p>
						<img src="img/order.svg" alt="">
					</small>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.item {
								order: 5; /* default is 0 */
							}
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<p>flex-grow</p>
					<small>
						<p>
							Define se um item pode "aumentar" se for necessário
						</p>
						<img src="img/flex-grow.svg" alt="">
					</small>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.item {
								flex-grow: 4; /* default 0 */
							}
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<p>flex-shrink</p>
					<small>
						<p>
							Define se um item pode "diminuir" se for necessário
						</p>
						<img src="img/flex-grow.svg" alt="">
					</small>

					<pre>
						<code class="hljs" data-trim contenteditable>
							.item {
								flex-shrink: 3; /* default 1 */
							}
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<p>Para mais informação detalhada do flex, consultar <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">este artigo.</a></p>
				</section>

				<section class="text-left">
					<h2>Vendor Prefixes</h2>
					<p>É uma maneira que os browsers usam para dar acesso aos developers a novas funcionalidades de CSS que ainda não são consideradas estáveis.</p>
					<p>No entanto alguns developers também usam os vendor prefixes para adicionar regras de CSS especificas para alguns browsers (wrong!)</p>
				</section>

				<section class="text-left">
					<pre>
						<code class="hljs" data-trim contenteditable>
							-webkit- (Chrome, Safari, iOS Safari / iOS WebView, Android)
    					-moz- (Firefox)
    					-ms- (Edge, Internet Explorer)
    					-o- (Opera, Opera Mini)
					 </code>
				 </pre>
				</section>

				<section class="text-left">
					<pre>
						<code class="hljs" data-trim contenteditable>
							.myClass {
								-webkit-transition: all 1s linear;
								-moz-transition: all 1s linear;
								-ms-transition: all 1s linear;
								-o-transition: all 1s linear;
								transition: all 1s linear;
							}
					 </code>
				 </pre>

				 <pre>
					<code class="hljs" data-trim contenteditable>
						.myClass {
							transition: all 1s linear;
						}
				 	</code>
			 		</pre>
				</section>

				<section class="text-left">
					<p>Podemos ver <a href="https://css-tricks.com/is-vendor-prefixing-dead/">neste artigo</a> os vendor prefixes ainda suportados hoje.</p>
				</section>

        <section class="text-left">
					<h3>Animações e Transições</h3>
					<ul>
						<li>Dar vida a elementos</li>
						<li>Dar a percepção que algo tem movimento</li>
					</ul>
				</section>

				<section class="text-left">
					<h3>Movimentos em CSS</h3>
					<ul>
						<li>Propriedade Transition</li>
						<li>Propriedade Animation + Keyframes</li>
					</ul>
				</section>

				<section class="text-left">
					Transições
				</section>

				<section class="text-left">
					<h3>Sintaxe:</h3>

					<pre>
					 		<code class="hljs" data-trim contenteditable>
					.elemento {
						transition: [property] [duration] [effect] [delay];
					}
							</code>
						</pre>
				</section>

				<section class="text-left">
					<h3>Sintaxe:</h3>

					<pre>
					 		<code class="hljs" data-trim contenteditable>
					.elemento {
						transition: opacity 300ms ease-in-out 1s;
					}
							</code>
						</pre>
				</section>

				<section class="text-left">
					<h3>[effect]</h3>

					<ul>
						<li>ease - transição que começa devagar, depois rápido e acaba devagar</li>
						<li>linear - velocidade igual no inicio e no fim</li>
						<li>ease-in - velocidade mais rápida no fim</li>
						<li>ease-out - velocidade mais rápida no início</li>
						<li>ease-in-out - começo e fim mais lento</li>
						<li>cubic-bezier(n,n,n,n) - podemos definir a velocidade desejada</li>
					</ul>

				</section>


				<section class="text-left">
					<h3>Propriedades que podem ser animadas:</h3>
					<ul>
						<li>Font-size:</li>
						<li>background-color:</li>
						<li>width:</li>
						<li>left:</li>
					</ul>
				</section>

				<section class="text-left">
					Propriedades que não podem ser animadas:
					<ul>
						<li>display</li>
						<li>font-family:</li>
						<li>position:</li>
					</ul>
				</section>

				<section class="text-left">
					<h3>As propriedades melhores para animar</h3>
					<ul>
						<li>posição</li>
						<li>scale:</li>
						<li>rotation:</li>
						<li>opacity:</li>
					</ul>
				</section>

				<section class="text-left">
					<h3>Como podemos começar uma animação?</h3>
					<ul>
						<li>Hover - pseudo class</li>
						<li>Mudanças de classes</li>
					</ul>
				</section>

				<section class="text-left">
					<h3>Para além do CSS3</h3>

					<p class="al">Existem libraries em JavaScript que nos auxiliam a disparar animações aos elementos</p>
				</section>

				<section class="text-left">
					Animações
				</section>

				<section>
					Propriedade Animation e Keyframes
				</section>

				<section class="text-left">
					Keyframes
				</section>

				<section class="text-left">
					<h3>Sintaxe:</h3>

					<pre>
					 		<code class="hljs" data-trim contenteditable>
						@keyframes [name] {
							from {
								[styles]
							}
							to {
								[styles]
							}
						}
							</code>
						</pre>
				</section>

				<section class="text-left">
					<h3>Sintaxe:</h3>

					<pre>
					 		<code class="hljs" data-trim contenteditable>
						@keyframes [name] {
							from {
								height: 200px;
								background: orange;
							}
							to {
								height: 400px;
								background: blue;
							}
						}
							</code>
						</pre>
				</section>

				<section class="text-left">
					<h3>Sintaxe:</h3>
					<pre>
					 		<code class="hljs" data-trim contenteditable>
						.element {
							animation: [name] [duration] [timing-function] [delay] [iteration-count] [direction] [fill-mode] [play-state];
						}
							</code>

						</pre>
				</section>

				<section class="text-left">
					Os Keyframes representam o que a animação faz, e a "animation" representa como é que deve ser feito.
				</section>

				<section class="text-left">
					<pre>
					 		<code class="hljs" data-trim contenteditable>
						.element {
							animation: timeline 2s ease-in-out 0s infinite normal forwards paused;
						}
							</code>
						</pre>
				</section>





				<section class="text-left">
					<pre>
					 <code class="hljs" data-trim contenteditable>
						transition-property: color;
						transition-duration: 1s;
						transition-timing-function: linear;
						transition-delay: 0.5s;
					 </code>
					 </pre>

					 <pre>
					 <code class="hljs" data-trim contenteditable>
						transition: color 1s linear 0.5s;
					 </code>
					 </pre>
				</section>

				<section class="text-left">
					transition-property é usada para determinar que transições vamos utilizar

					<pre>
					 <code class="hljs" data-trim contenteditable>
						transition-property: color;

						transition-property: all;
						 </code>
					 </pre>

					<pre>
					 <code class="hljs" data-trim contenteditable>
					 transition-property: all;
						 </code>
					 </pre>

				</section>


				<section class="text-left">
					Nem todas as propriedades podem ter transições.
				</section>

				<section>
					<p class="al">translation-duration define quanto tempo a transição irá durar</p>
					<p class="al">
						Podemos defenir o valor em segundos ou milisegundos
					</p>
				</section>

				<section class="text-left">
					<pre>
					 <code class="hljs" data-trim contenteditable>
					 /* em segundos */
					 transition-duration: 1s;
					 transition-duration: 0.5s;

					 /* em milisegundos */
					 transition-duration: 1000ms;
					 transition-duration: 500ms;
						 </code>
					 </pre>
				</section>

				<section class="text-left">
					<p class="al">transition-timing-funtion: usada para definir a curva de aceleração relativa à duração da animação-</p>

					<pre>
					 <code class="hljs" data-trim contenteditable>
					 transition-timing-function: ease;
					 transition-timing-funtion: ease-in;
						 </code>
					 </pre>
				</section>

				<section class="text-left">
					<p class="al">transition-delay: usada para colocar um delay à animação, definido em segundos ou milisegundos-</p>

					<pre>
					 <code class="hljs" data-trim contenteditable>
					 transition-delay: 0.5s
						 </code>
					 </pre>

					 <p class="al">Se não for definido, não existirá delay</p>
				</section>

				<section class="text-left">
					ver exemplo 1
				</section>

				<section class="text-left">
					<p class="al">A transition só tem um ponto de partida e um ponto de chegada</p>

					<p class="al">Com os keyframes podemos criar animações mais complexas.</p>
				</section>

				<section class="text-left">
					<p class="al">
						Para usar os @keyframes, precisamos de três coisas:
					</p>

					<ol>
						<li>Nome da animação</li>
						<li>Breakpoints</li>
						<li>Propriedades de CSS para serem animadas</li>
					</ol>
				</section>

				<section class="text-left">
					<pre>
					 <code class="hljs" data-trim contenteditable>
						 @keyframes nome-animacao {

					 }

					 </code>
					 </pre>
				</section>


				<section class="text-left">
					<p class="al">Animações só podem ser aplicadas na mesma propriedade de inicio e fim</p>
				</section>


				<section class="text-left">
					<p class="al">Esta animação está incorrecta e não vai funcionar:</p>
					<pre>
					 <code class="hljs" data-trim contenteditable>
						 @keyframes nome-animacao {
						0% {
						top: 0px;
						}
						100% {
						bottom: 0px;
						}
					 }

					 </code>
					 </pre>
				</section>

				<section class="text-left">
					<p class="al">Utiliza-se @keyframes para definit a animação</p>

					<p class="al">Utiliza-se a propriedade animation-name para aplicar a animação</p>
				</section>

				<section class="text-left">
					<code class="hljs" data-trim contenteditable>
						 @keyframes nome-animacao {
						0% {
						top: 0px;
						}
						100% {
						top: 250px;
						}
					 }

					 </code>
					 </pre>

					 <code class="hljs" data-trim contenteditable>
						 .ball {
						 animation-name: bounce;
						 animation-duration: 1s;
					 }

					 </code>
					 </pre>
				</section>

				<section class="text-left">
					<p class="al">Propriedades da animação opcionais:</p>

					<code class="hljs" data-trim contenteditable>
						 animation-timing-fuction: ease-out;
						 animation-delay: 1s;
					 </code>
					 </pre>
				</section>

				<section class="text-left">
					<p class="al">Para repetir a animação, utilizamos o:</p>

					<code class="hljs" data-trim contenteditable>
						 animation-iteration-count: 3;
						 /* ou */
						 animation-iteration-count: infinite;
					 }
					 </code>
					 </pre>
				</section>

				<section class="text-left">
					ver exemplo 2
				</section>

				<section class="text-left">
					Exercícios 1, 2 e 2.1
				</section>

				<section class="text-left">
					Frameworks de animação - https://daneden.github.io/animate.css/
				</section>


			</div>

		</div>

        <script src="../revealjs/dist/reveal.js"></script>
        <script src="../revealjs/plugin/highlight/highlight.js"></script>

        <script>
            Reveal.initialize({
              center: true,
              hash: true,
              plugins: [RevealHighlight]
            });
          </script>

	</body>
</html>
